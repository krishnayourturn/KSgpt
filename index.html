<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Side Scroller Game</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box;}
  body{overflow:hidden;font-family:sans-serif;background:#000;}
  canvas{display:block;margin:0 auto;}
  #hud{
    position:absolute;top:10px;left:10px;color:#fff;font-size:18px;
    background:rgba(0,0,0,0.4);padding:8px 12px;border-radius:8px;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="500"></canvas>
<div id="hud">Score: 0 | Health: 3</div>
<script>
// === CANVAS SETUP ===
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
const width=canvas.width;
const height=canvas.height;

// === LOAD IMAGES ===
const images = {
  player: new Image(),
  enemy: new Image(),
  background: new Image()
};
images.player.src = 'assets/player/Player.PNG';
images.enemy.src = 'assets/enemy/Enemy.PNG';
images.background.src = 'assets/screens/38B6D2B8-11A7-481F-8DAA-246E6F467D16.png';

// === GAME STATE ===
let gameState='start';
let score=0;
let worldOffsetX=0;

// === PLAYER ===
const player={
  x:100,y:height-100,width:50,height:50,speed:5,bullets:[],health:3,lastShot:0
};

// === ENEMY ===
class Enemy{
  constructor(xStart,xEnd){
    this.zoneStart=xStart; this.zoneEnd=xEnd;
    this.width=50; this.height=50;
    this.x=xStart + Math.random()*(xEnd-xStart-this.width);
    this.y=height-100;
    this.speed=2; this.direction=1;
    this.bullets=[]; this.shootCooldown=Math.floor(Math.random()*100)+50;
  }
  move(){
    this.x+=this.speed*this.direction;
    if(this.x<this.zoneStart || this.x+this.width>this.zoneEnd) this.direction*=-1;
    this.shootCooldown--;
    if(this.shootCooldown<=0){
      this.bullets.push({x:this.x,y:this.y+this.height/2,width:8,height:8,speed:-5});
      this.shootCooldown=Math.floor(Math.random()*150)+50;
    }
    this.bullets.forEach((b,i)=>{
      b.x+=b.speed;
      if(b.x<0) this.bullets.splice(i,1);
      if(b.x<player.x+player.width && b.x+b.width>player.x && b.y<player.y+player.height && b.y+b.height>player.y){
        player.health--; this.bullets.splice(i,1);
        if(player.health<=0) gameState='gameover';
      }
    });
  }
  draw(offsetX){
    ctx.drawImage(images.enemy,this.x-offsetX,this.y,this.width,this.height);
    this.bullets.forEach(b=>{
      ctx.fillStyle='orange';
      ctx.fillRect(b.x-offsetX,b.y,b.width,b.height);
    });
  }
}

// === ENEMIES ===
let enemyZones=[
  {xStart:500,xEnd:800,spawned:false},
  {xStart:1200,xEnd:1600,spawned:false},
  {xStart:2000,xEnd:2500,spawned:false},
];
let enemies=[];

function initEnemies(){enemies=[];enemyZones.forEach(z=>z.spawned=false);spawnEnemies();}
function spawnEnemies(){
  enemyZones.forEach(zone=>{
    if(worldOffsetX+width>zone.xStart && !zone.spawned){
      let count=Math.floor(Math.random()*2)+1;
      for(let i=0;i<count;i++) enemies.push(new Enemy(zone.xStart,zone.xEnd));
      zone.spawned=true;
    }
  });
}

// === BULLETS ===
class Bullet{constructor(x,y,speed){this.x=x;this.y=y;this.width=8;this.height=8;this.speed=speed;}
update(){this.x+=this.speed;} draw(){ctx.fillStyle='yellow';ctx.fillRect(this.x,this.y,this.width,this.height);}}

// === CONTROLS ===
const keys={};
window.addEventListener('keydown',e=>keys[e.key]=true);
window.addEventListener('keyup',e=>keys[e.key]=false);

// === UPDATE FUNCTION ===
function update(){
  if(gameState!=='playing') return;

  // Player movement
  if(keys['ArrowLeft'] && player.x>50) player.x-=player.speed;
  if(keys['ArrowRight'] && player.x<width/2) player.x+=player.speed;

  // Scroll world
  if(keys['ArrowRight'] && player.x>=width/2) worldOffsetX+=player.speed;

  // Shooting
  if(keys[' '] && Date.now()-player.lastShot>300){
    player.bullets.push(new Bullet(player.x+player.width,player.y+player.height/2,8));
    player.lastShot=Date.now();
  }

  // Update bullets
  player.bullets.forEach((b,i)=>{
    b.update();
    if(b.x>worldOffsetX+width) player.bullets.splice(i,1);
    enemies.forEach((e,ei)=>{
      if(b.x<e.x+e.width && b.x+b.width>e.x && b.y<e.y+e.height && b.y+b.height>e.y){
        enemies.splice(ei,1);
        player.bullets.splice(i,1);
        score+=10;
      }
    });
  });

  // Update enemies
  enemies.forEach(e=>e.move());

  // Spawn new enemies dynamically
  spawnEnemies();

  // HUD
  document.getElementById('hud').innerText=`Score: ${score} | Health: ${player.health}`;
}

// === DRAW FUNCTION ===
function draw(){
  ctx.clearRect(0,0,width,height);

  // Draw background
  ctx.drawImage(images.background,-worldOffsetX,0,width,height);
  ctx.drawImage(images.background,-worldOffsetX+width,0,width,height);

  if(gameState==='start'){
    ctx.fillStyle='black';
    ctx.font='40px sans-serif';
    ctx.textAlign='center';
    ctx.fillText('Press ENTER to Start',width/2,height/2);
  } else if(gameState==='playing'){
    ctx.drawImage(images.player,player.x,player.y,player.width,player.height);
    player.bullets.forEach(b=>b.draw());
    enemies.forEach(e=>e.draw(worldOffsetX));
  } else if(gameState==='gameover'){
    ctx.fillStyle='black';
    ctx.font='50px sans-serif';
    ctx.textAlign='center';
    ctx.fillText('GAME OVER',width/2,height/2-30);
    ctx.fillStyle='white';
    ctx.font='30px sans-serif';
    ctx.fillText(`Score: ${score}`,width/2,height/2+10);
    ctx.fillText('Press ENTER to Restart',width/2,height/2+50);
  }
}

// === GAME LOOP ===
function gameLoop(){update();draw();requestAnimationFrame(gameLoop);}

// === START / RESTART ===
window.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    if(gameState==='start'||gameState==='gameover'){
      gameState='playing';
      player.x=100;player.y=height-100;player.health=3;player.bullets=[];score=0;worldOffsetX=0;
      initEnemies();
    }
  }
});

gameLoop();
</script>
</body>
</html>
